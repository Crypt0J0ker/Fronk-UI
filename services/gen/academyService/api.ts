/* tslint:disable */
/* eslint-disable */
/**
 * Force-academy-backend
 * Force academy api swagger interface
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AdminCreateDto
 */
export interface AdminCreateDto {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateDto
     */
    'wallet': string;
}
/**
 * 
 * @export
 * @interface AdminLogDto
 */
export interface AdminLogDto {
    /**
     * 
     * @type {string}
     * @memberof AdminLogDto
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminLogDto
     */
    'area': string;
    /**
     * 
     * @type {string}
     * @memberof AdminLogDto
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof AdminLogDto
     */
    'wallet': string;
    /**
     * 
     * @type {string}
     * @memberof AdminLogDto
     */
    'action': string;
    /**
     * 
     * @type {object}
     * @memberof AdminLogDto
     */
    'value': object;
    /**
     * 
     * @type {string}
     * @memberof AdminLogDto
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface AdminReadDto
 */
export interface AdminReadDto {
    /**
     * 
     * @type {string}
     * @memberof AdminReadDto
     */
    'wallet': string;
    /**
     * 
     * @type {string}
     * @memberof AdminReadDto
     */
    '_id': string | null;
}
/**
 * 
 * @export
 * @interface AnswerCreateDto
 */
export interface AnswerCreateDto {
    /**
     * 
     * @type {Array<AnswerLangDto>}
     * @memberof AnswerCreateDto
     */
    'text': Array<AnswerLangDto>;
    /**
     * 
     * @type {boolean}
     * @memberof AnswerCreateDto
     */
    'isCorrect': boolean;
}
/**
 * 
 * @export
 * @interface AnswerDto
 */
export interface AnswerDto {
    /**
     * 
     * @type {Array<QuestionLangDto>}
     * @memberof AnswerDto
     */
    'text': Array<QuestionLangDto>;
    /**
     * 
     * @type {boolean}
     * @memberof AnswerDto
     */
    'isCorrect': boolean;
}
/**
 * 
 * @export
 * @interface AnswerLangDto
 */
export interface AnswerLangDto {
    /**
     * 
     * @type {string}
     * @memberof AnswerLangDto
     */
    'lang': string;
    /**
     * 
     * @type {string}
     * @memberof AnswerLangDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface AnswerPublicDto
 */
export interface AnswerPublicDto {
    /**
     * 
     * @type {Array<QuestionLangDto>}
     * @memberof AnswerPublicDto
     */
    'text': Array<QuestionLangDto>;
    /**
     * 
     * @type {string}
     * @memberof AnswerPublicDto
     */
    '_id': string | null;
}
/**
 * 
 * @export
 * @interface AnswerReadDto
 */
export interface AnswerReadDto {
    /**
     * 
     * @type {Array<AnswerLangDto>}
     * @memberof AnswerReadDto
     */
    'text': Array<AnswerLangDto>;
    /**
     * 
     * @type {boolean}
     * @memberof AnswerReadDto
     */
    'isCorrect': boolean;
    /**
     * 
     * @type {string}
     * @memberof AnswerReadDto
     */
    '_id': string | null;
}
/**
 * 
 * @export
 * @interface AnswerUpdateDto
 */
export interface AnswerUpdateDto {
    /**
     * 
     * @type {Array<AnswerLangDto>}
     * @memberof AnswerUpdateDto
     */
    'text'?: Array<AnswerLangDto>;
    /**
     * 
     * @type {boolean}
     * @memberof AnswerUpdateDto
     */
    'isCorrect'?: boolean;
}
/**
 * 
 * @export
 * @interface BlockCreateDto
 */
export interface BlockCreateDto {
    /**
     * 
     * @type {string}
     * @memberof BlockCreateDto
     */
    'icon': string;
    /**
     * 
     * @type {boolean}
     * @memberof BlockCreateDto
     */
    'isPublished': boolean;
    /**
     * 
     * @type {string}
     * @memberof BlockCreateDto
     */
    'image': string;
    /**
     * 
     * @type {Array<BlockLangDto>}
     * @memberof BlockCreateDto
     */
    'languages': Array<BlockLangDto>;
}
/**
 * 
 * @export
 * @interface BlockLangDto
 */
export interface BlockLangDto {
    /**
     * 
     * @type {string}
     * @memberof BlockLangDto
     */
    'lang': string;
    /**
     * 
     * @type {string}
     * @memberof BlockLangDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BlockLangDto
     */
    'about': string;
}
/**
 * 
 * @export
 * @interface BlockReadDto
 */
export interface BlockReadDto {
    /**
     * 
     * @type {string}
     * @memberof BlockReadDto
     */
    'icon': string;
    /**
     * 
     * @type {boolean}
     * @memberof BlockReadDto
     */
    'isPublished': boolean;
    /**
     * 
     * @type {string}
     * @memberof BlockReadDto
     */
    'image': string;
    /**
     * 
     * @type {Array<BlockLangDto>}
     * @memberof BlockReadDto
     */
    'languages': Array<BlockLangDto>;
    /**
     * 
     * @type {string}
     * @memberof BlockReadDto
     */
    '_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof BlockReadDto
     */
    'contractAddress': string;
    /**
     * 
     * @type {Array<LessonReadDto>}
     * @memberof BlockReadDto
     */
    'lessons': Array<LessonReadDto>;
    /**
     * 
     * @type {Array<QuestionReadDto>}
     * @memberof BlockReadDto
     */
    'questions': Array<QuestionReadDto>;
}
/**
 * 
 * @export
 * @interface BlockUpdateDto
 */
export interface BlockUpdateDto {
    /**
     * 
     * @type {string}
     * @memberof BlockUpdateDto
     */
    'icon'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BlockUpdateDto
     */
    'isPublished'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BlockUpdateDto
     */
    'image'?: string;
    /**
     * 
     * @type {Array<BlockLangDto>}
     * @memberof BlockUpdateDto
     */
    'languages'?: Array<BlockLangDto>;
}
/**
 * 
 * @export
 * @interface LessonCreateDto
 */
export interface LessonCreateDto {
    /**
     * 
     * @type {Array<LessonLangDto>}
     * @memberof LessonCreateDto
     */
    'languages': Array<LessonLangDto>;
    /**
     * 
     * @type {boolean}
     * @memberof LessonCreateDto
     */
    'isPublished': boolean;
}
/**
 * 
 * @export
 * @interface LessonLangDto
 */
export interface LessonLangDto {
    /**
     * 
     * @type {string}
     * @memberof LessonLangDto
     */
    'lang': string;
    /**
     * 
     * @type {string}
     * @memberof LessonLangDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LessonLangDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface LessonReadDto
 */
export interface LessonReadDto {
    /**
     * 
     * @type {Array<LessonLangDto>}
     * @memberof LessonReadDto
     */
    'languages': Array<LessonLangDto>;
    /**
     * 
     * @type {boolean}
     * @memberof LessonReadDto
     */
    'isPublished': boolean;
    /**
     * 
     * @type {string}
     * @memberof LessonReadDto
     */
    '_id': string | null;
    /**
     * 
     * @type {Array<LessonSlideReadDto>}
     * @memberof LessonReadDto
     */
    'slides': Array<LessonSlideReadDto>;
}
/**
 * 
 * @export
 * @interface LessonResult
 */
export interface LessonResult {
    /**
     * 
     * @type {string}
     * @memberof LessonResult
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof LessonResult
     */
    'progress': number;
}
/**
 * 
 * @export
 * @interface LessonSlideCreateDto
 */
export interface LessonSlideCreateDto {
    /**
     * 
     * @type {Array<LessonSlideLangDto>}
     * @memberof LessonSlideCreateDto
     */
    'languages': Array<LessonSlideLangDto>;
}
/**
 * 
 * @export
 * @interface LessonSlideLangDto
 */
export interface LessonSlideLangDto {
    /**
     * 
     * @type {string}
     * @memberof LessonSlideLangDto
     */
    'lang': string;
    /**
     * 
     * @type {string}
     * @memberof LessonSlideLangDto
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof LessonSlideLangDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface LessonSlideReadDto
 */
export interface LessonSlideReadDto {
    /**
     * 
     * @type {Array<LessonSlideLangDto>}
     * @memberof LessonSlideReadDto
     */
    'languages': Array<LessonSlideLangDto>;
    /**
     * 
     * @type {string}
     * @memberof LessonSlideReadDto
     */
    '_id': string | null;
}
/**
 * 
 * @export
 * @interface LessonSlideUpdateDto
 */
export interface LessonSlideUpdateDto {
    /**
     * 
     * @type {Array<LessonSlideLangDto>}
     * @memberof LessonSlideUpdateDto
     */
    'languages'?: Array<LessonSlideLangDto>;
}
/**
 * 
 * @export
 * @interface LessonUpdateDto
 */
export interface LessonUpdateDto {
    /**
     * 
     * @type {Array<LessonLangDto>}
     * @memberof LessonUpdateDto
     */
    'languages'?: Array<LessonLangDto>;
    /**
     * 
     * @type {boolean}
     * @memberof LessonUpdateDto
     */
    'isPublished'?: boolean;
}
/**
 * 
 * @export
 * @interface PagingDataAdminLogDto
 */
export interface PagingDataAdminLogDto {
    /**
     * 
     * @type {number}
     * @memberof PagingDataAdminLogDto
     */
    'total': number;
    /**
     * 
     * @type {Array<AdminLogDto>}
     * @memberof PagingDataAdminLogDto
     */
    'data': Array<AdminLogDto>;
}
/**
 * 
 * @export
 * @interface QuestionCreateDto
 */
export interface QuestionCreateDto {
    /**
     * 
     * @type {Array<QuestionLangDto>}
     * @memberof QuestionCreateDto
     */
    'languages': Array<QuestionLangDto>;
}
/**
 * 
 * @export
 * @interface QuestionLangDto
 */
export interface QuestionLangDto {
    /**
     * 
     * @type {string}
     * @memberof QuestionLangDto
     */
    'lang': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionLangDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface QuestionPublicDto
 */
export interface QuestionPublicDto {
    /**
     * 
     * @type {Array<QuestionLangDto>}
     * @memberof QuestionPublicDto
     */
    'languages': Array<QuestionLangDto>;
    /**
     * 
     * @type {string}
     * @memberof QuestionPublicDto
     */
    '_id': string | null;
    /**
     * 
     * @type {Array<AnswerPublicDto>}
     * @memberof QuestionPublicDto
     */
    'answers': Array<AnswerPublicDto>;
}
/**
 * 
 * @export
 * @interface QuestionReadDto
 */
export interface QuestionReadDto {
    /**
     * 
     * @type {Array<QuestionLangDto>}
     * @memberof QuestionReadDto
     */
    'languages': Array<QuestionLangDto>;
    /**
     * 
     * @type {string}
     * @memberof QuestionReadDto
     */
    '_id': string | null;
    /**
     * 
     * @type {Array<AnswerDto>}
     * @memberof QuestionReadDto
     */
    'answers': Array<AnswerDto>;
}
/**
 * 
 * @export
 * @interface QuestionUpdateDto
 */
export interface QuestionUpdateDto {
    /**
     * 
     * @type {Array<QuestionLangDto>}
     * @memberof QuestionUpdateDto
     */
    'languages'?: Array<QuestionLangDto>;
}
/**
 * 
 * @export
 * @interface UserSummaryDto
 */
export interface UserSummaryDto {
    /**
     * 
     * @type {Array<LessonResult>}
     * @memberof UserSummaryDto
     */
    'lessons': Array<LessonResult>;
    /**
     * 
     * @type {Array<UserTestCheckResultDto>}
     * @memberof UserSummaryDto
     */
    'blockTests': Array<UserTestCheckResultDto>;
}
/**
 * 
 * @export
 * @interface UserTestCheckResultDto
 */
export interface UserTestCheckResultDto {
    /**
     * 
     * @type {boolean}
     * @memberof UserTestCheckResultDto
     */
    'isPass': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserTestCheckResultDto
     */
    'blockId': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserTestCheckResultDto
     */
    'isClaimed': boolean;
}
/**
 * 
 * @export
 * @interface UserTestResultAnswersDto
 */
export interface UserTestResultAnswersDto {
    /**
     * 
     * @type {string}
     * @memberof UserTestResultAnswersDto
     */
    'questionId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserTestResultAnswersDto
     */
    'selectedAnswersIds': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserTestResultAnswersDto
     */
    'unselectedAnswersIds': Array<string>;
}
/**
 * 
 * @export
 * @interface UserTestResultDto
 */
export interface UserTestResultDto {
    /**
     * 
     * @type {string}
     * @memberof UserTestResultDto
     */
    'blockId': string;
    /**
     * 
     * @type {Array<UserTestResultAnswersDto>}
     * @memberof UserTestResultDto
     */
    'answers': Array<UserTestResultAnswersDto>;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AdminCreateDto} adminCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerCreateAdmin: async (adminCreateDto: AdminCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateDto' is not null or undefined
            assertParamExists('adminControllerCreateAdmin', 'adminCreateDto', adminCreateDto)
            const localVarPath = `/bck/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerDeleteAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminControllerDeleteAdmin', 'id', id)
            const localVarPath = `/bck/admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerGetAdmins: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerIsAdmin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/admin/isAdmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AdminCreateDto} adminCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminControllerCreateAdmin(adminCreateDto: AdminCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerCreateAdmin(adminCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminControllerDeleteAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerDeleteAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminControllerGetAdmins(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdminReadDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerGetAdmins(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminControllerIsAdmin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerIsAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @param {AdminCreateDto} adminCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerCreateAdmin(adminCreateDto: AdminCreateDto, options?: any): AxiosPromise<AdminReadDto> {
            return localVarFp.adminControllerCreateAdmin(adminCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerDeleteAdmin(id: string, options?: any): AxiosPromise<AdminReadDto> {
            return localVarFp.adminControllerDeleteAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerGetAdmins(options?: any): AxiosPromise<Array<AdminReadDto>> {
            return localVarFp.adminControllerGetAdmins(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerIsAdmin(options?: any): AxiosPromise<boolean> {
            return localVarFp.adminControllerIsAdmin(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - interface
 * @export
 * @interface AdminApi
 */
export interface AdminApiInterface {
    /**
     * 
     * @param {AdminCreateDto} adminCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminControllerCreateAdmin(adminCreateDto: AdminCreateDto, options?: AxiosRequestConfig): AxiosPromise<AdminReadDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminControllerDeleteAdmin(id: string, options?: AxiosRequestConfig): AxiosPromise<AdminReadDto>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminControllerGetAdmins(options?: AxiosRequestConfig): AxiosPromise<Array<AdminReadDto>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiInterface
     */
    adminControllerIsAdmin(options?: AxiosRequestConfig): AxiosPromise<boolean>;

}

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI implements AdminApiInterface {
    /**
     * 
     * @param {AdminCreateDto} adminCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminControllerCreateAdmin(adminCreateDto: AdminCreateDto, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminControllerCreateAdmin(adminCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminControllerDeleteAdmin(id: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminControllerDeleteAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminControllerGetAdmins(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminControllerGetAdmins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminControllerIsAdmin(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminControllerIsAdmin(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdminLogsApi - axios parameter creator
 * @export
 */
export const AdminLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLogsControllerGetLogItem: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminLogsControllerGetLogItem', 'id', id)
            const localVarPath = `/bck/admin-logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [wallet] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLogsControllerGetLogs: async (wallet?: string, skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/admin-logs/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (wallet !== undefined) {
                localVarQueryParameter['wallet'] = wallet;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminLogsApi - functional programming interface
 * @export
 */
export const AdminLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminLogsControllerGetLogItem(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminLogDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminLogsControllerGetLogItem(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [wallet] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminLogsControllerGetLogs(wallet?: string, skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagingDataAdminLogDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminLogsControllerGetLogs(wallet, skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminLogsApi - factory interface
 * @export
 */
export const AdminLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminLogsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLogsControllerGetLogItem(id: string, options?: any): AxiosPromise<AdminLogDto> {
            return localVarFp.adminLogsControllerGetLogItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [wallet] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLogsControllerGetLogs(wallet?: string, skip?: number, limit?: number, options?: any): AxiosPromise<PagingDataAdminLogDto> {
            return localVarFp.adminLogsControllerGetLogs(wallet, skip, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminLogsApi - interface
 * @export
 * @interface AdminLogsApi
 */
export interface AdminLogsApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLogsApiInterface
     */
    adminLogsControllerGetLogItem(id: string, options?: AxiosRequestConfig): AxiosPromise<AdminLogDto>;

    /**
     * 
     * @param {string} [wallet] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLogsApiInterface
     */
    adminLogsControllerGetLogs(wallet?: string, skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<PagingDataAdminLogDto>;

}

/**
 * AdminLogsApi - object-oriented interface
 * @export
 * @class AdminLogsApi
 * @extends {BaseAPI}
 */
export class AdminLogsApi extends BaseAPI implements AdminLogsApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLogsApi
     */
    public adminLogsControllerGetLogItem(id: string, options?: AxiosRequestConfig) {
        return AdminLogsApiFp(this.configuration).adminLogsControllerGetLogItem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [wallet] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLogsApi
     */
    public adminLogsControllerGetLogs(wallet?: string, skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminLogsApiFp(this.configuration).adminLogsControllerGetLogs(wallet, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AnswersApi - axios parameter creator
 * @export
 */
export const AnswersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerControllerDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/answer/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerControllerDeleteAnswer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('answerControllerDeleteAnswer', 'id', id)
            const localVarPath = `/bck/answer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerControllerGetAnswer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('answerControllerGetAnswer', 'id', id)
            const localVarPath = `/bck/answer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerControllerGetAnswers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/answer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AnswerUpdateDto} answerUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerControllerUpdateAnswer: async (id: string, answerUpdateDto: AnswerUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('answerControllerUpdateAnswer', 'id', id)
            // verify required parameter 'answerUpdateDto' is not null or undefined
            assertParamExists('answerControllerUpdateAnswer', 'answerUpdateDto', answerUpdateDto)
            const localVarPath = `/bck/answer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(answerUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnswersApi - functional programming interface
 * @export
 */
export const AnswersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnswersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async answerControllerDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.answerControllerDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async answerControllerDeleteAnswer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnswerReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.answerControllerDeleteAnswer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async answerControllerGetAnswer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnswerReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.answerControllerGetAnswer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async answerControllerGetAnswers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnswerReadDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.answerControllerGetAnswers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {AnswerUpdateDto} answerUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async answerControllerUpdateAnswer(id: string, answerUpdateDto: AnswerUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnswerReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.answerControllerUpdateAnswer(id, answerUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnswersApi - factory interface
 * @export
 */
export const AnswersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnswersApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerControllerDeleteAll(options?: any): AxiosPromise<void> {
            return localVarFp.answerControllerDeleteAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerControllerDeleteAnswer(id: string, options?: any): AxiosPromise<AnswerReadDto> {
            return localVarFp.answerControllerDeleteAnswer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerControllerGetAnswer(id: string, options?: any): AxiosPromise<AnswerReadDto> {
            return localVarFp.answerControllerGetAnswer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerControllerGetAnswers(options?: any): AxiosPromise<Array<AnswerReadDto>> {
            return localVarFp.answerControllerGetAnswers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {AnswerUpdateDto} answerUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerControllerUpdateAnswer(id: string, answerUpdateDto: AnswerUpdateDto, options?: any): AxiosPromise<AnswerReadDto> {
            return localVarFp.answerControllerUpdateAnswer(id, answerUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnswersApi - interface
 * @export
 * @interface AnswersApi
 */
export interface AnswersApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswersApiInterface
     */
    answerControllerDeleteAll(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswersApiInterface
     */
    answerControllerDeleteAnswer(id: string, options?: AxiosRequestConfig): AxiosPromise<AnswerReadDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswersApiInterface
     */
    answerControllerGetAnswer(id: string, options?: AxiosRequestConfig): AxiosPromise<AnswerReadDto>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswersApiInterface
     */
    answerControllerGetAnswers(options?: AxiosRequestConfig): AxiosPromise<Array<AnswerReadDto>>;

    /**
     * 
     * @param {string} id 
     * @param {AnswerUpdateDto} answerUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswersApiInterface
     */
    answerControllerUpdateAnswer(id: string, answerUpdateDto: AnswerUpdateDto, options?: AxiosRequestConfig): AxiosPromise<AnswerReadDto>;

}

/**
 * AnswersApi - object-oriented interface
 * @export
 * @class AnswersApi
 * @extends {BaseAPI}
 */
export class AnswersApi extends BaseAPI implements AnswersApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswersApi
     */
    public answerControllerDeleteAll(options?: AxiosRequestConfig) {
        return AnswersApiFp(this.configuration).answerControllerDeleteAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswersApi
     */
    public answerControllerDeleteAnswer(id: string, options?: AxiosRequestConfig) {
        return AnswersApiFp(this.configuration).answerControllerDeleteAnswer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswersApi
     */
    public answerControllerGetAnswer(id: string, options?: AxiosRequestConfig) {
        return AnswersApiFp(this.configuration).answerControllerGetAnswer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswersApi
     */
    public answerControllerGetAnswers(options?: AxiosRequestConfig) {
        return AnswersApiFp(this.configuration).answerControllerGetAnswers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {AnswerUpdateDto} answerUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnswersApi
     */
    public answerControllerUpdateAnswer(id: string, answerUpdateDto: AnswerUpdateDto, options?: AxiosRequestConfig) {
        return AnswersApiFp(this.configuration).answerControllerUpdateAnswer(id, answerUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlocksApi - axios parameter creator
 * @export
 */
export const BlocksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {LessonCreateDto} lessonCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerAddLesson: async (id: string, lessonCreateDto: LessonCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('blockControllerAddLesson', 'id', id)
            // verify required parameter 'lessonCreateDto' is not null or undefined
            assertParamExists('blockControllerAddLesson', 'lessonCreateDto', lessonCreateDto)
            const localVarPath = `/bck/block/{id}/addLesson`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lessonCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {QuestionCreateDto} questionCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerAddQuestion: async (id: string, questionCreateDto: QuestionCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('blockControllerAddQuestion', 'id', id)
            // verify required parameter 'questionCreateDto' is not null or undefined
            assertParamExists('blockControllerAddQuestion', 'questionCreateDto', questionCreateDto)
            const localVarPath = `/bck/block/{id}/addQuestion`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BlockCreateDto} blockCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerCreateBlock: async (blockCreateDto: BlockCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockCreateDto' is not null or undefined
            assertParamExists('blockControllerCreateBlock', 'blockCreateDto', blockCreateDto)
            const localVarPath = `/bck/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/block/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerDeleteBlock: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('blockControllerDeleteBlock', 'id', id)
            const localVarPath = `/bck/block/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerGetBlock: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('blockControllerGetBlock', 'id', id)
            const localVarPath = `/bck/block/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerGetBlocks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerGetLessonQuestions: async (blockId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('blockControllerGetLessonQuestions', 'blockId', blockId)
            const localVarPath = `/bck/block/{blockId}/questions`
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerTestImage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/block/test/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {BlockUpdateDto} blockUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerUpdateBlock: async (id: string, blockUpdateDto: BlockUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('blockControllerUpdateBlock', 'id', id)
            // verify required parameter 'blockUpdateDto' is not null or undefined
            assertParamExists('blockControllerUpdateBlock', 'blockUpdateDto', blockUpdateDto)
            const localVarPath = `/bck/block/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlocksApi - functional programming interface
 * @export
 */
export const BlocksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlocksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {LessonCreateDto} lessonCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockControllerAddLesson(id: string, lessonCreateDto: LessonCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockControllerAddLesson(id, lessonCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {QuestionCreateDto} questionCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockControllerAddQuestion(id: string, questionCreateDto: QuestionCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockControllerAddQuestion(id, questionCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BlockCreateDto} blockCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockControllerCreateBlock(blockCreateDto: BlockCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockControllerCreateBlock(blockCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockControllerDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockControllerDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockControllerDeleteBlock(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockControllerDeleteBlock(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockControllerGetBlock(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockControllerGetBlock(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockControllerGetBlocks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockReadDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockControllerGetBlocks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockControllerGetLessonQuestions(blockId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockReadDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockControllerGetLessonQuestions(blockId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockControllerTestImage(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockControllerTestImage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {BlockUpdateDto} blockUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockControllerUpdateBlock(id: string, blockUpdateDto: BlockUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockCreateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockControllerUpdateBlock(id, blockUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlocksApi - factory interface
 * @export
 */
export const BlocksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlocksApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {LessonCreateDto} lessonCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerAddLesson(id: string, lessonCreateDto: LessonCreateDto, options?: any): AxiosPromise<BlockReadDto> {
            return localVarFp.blockControllerAddLesson(id, lessonCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {QuestionCreateDto} questionCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerAddQuestion(id: string, questionCreateDto: QuestionCreateDto, options?: any): AxiosPromise<BlockReadDto> {
            return localVarFp.blockControllerAddQuestion(id, questionCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BlockCreateDto} blockCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerCreateBlock(blockCreateDto: BlockCreateDto, options?: any): AxiosPromise<BlockReadDto> {
            return localVarFp.blockControllerCreateBlock(blockCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerDeleteAll(options?: any): AxiosPromise<void> {
            return localVarFp.blockControllerDeleteAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerDeleteBlock(id: string, options?: any): AxiosPromise<BlockReadDto> {
            return localVarFp.blockControllerDeleteBlock(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerGetBlock(id: string, options?: any): AxiosPromise<BlockReadDto> {
            return localVarFp.blockControllerGetBlock(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerGetBlocks(options?: any): AxiosPromise<Array<BlockReadDto>> {
            return localVarFp.blockControllerGetBlocks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerGetLessonQuestions(blockId: string, options?: any): AxiosPromise<Array<BlockReadDto>> {
            return localVarFp.blockControllerGetLessonQuestions(blockId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerTestImage(options?: any): AxiosPromise<void> {
            return localVarFp.blockControllerTestImage(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {BlockUpdateDto} blockUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockControllerUpdateBlock(id: string, blockUpdateDto: BlockUpdateDto, options?: any): AxiosPromise<BlockCreateDto> {
            return localVarFp.blockControllerUpdateBlock(id, blockUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlocksApi - interface
 * @export
 * @interface BlocksApi
 */
export interface BlocksApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {LessonCreateDto} lessonCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApiInterface
     */
    blockControllerAddLesson(id: string, lessonCreateDto: LessonCreateDto, options?: AxiosRequestConfig): AxiosPromise<BlockReadDto>;

    /**
     * 
     * @param {string} id 
     * @param {QuestionCreateDto} questionCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApiInterface
     */
    blockControllerAddQuestion(id: string, questionCreateDto: QuestionCreateDto, options?: AxiosRequestConfig): AxiosPromise<BlockReadDto>;

    /**
     * 
     * @param {BlockCreateDto} blockCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApiInterface
     */
    blockControllerCreateBlock(blockCreateDto: BlockCreateDto, options?: AxiosRequestConfig): AxiosPromise<BlockReadDto>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApiInterface
     */
    blockControllerDeleteAll(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApiInterface
     */
    blockControllerDeleteBlock(id: string, options?: AxiosRequestConfig): AxiosPromise<BlockReadDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApiInterface
     */
    blockControllerGetBlock(id: string, options?: AxiosRequestConfig): AxiosPromise<BlockReadDto>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApiInterface
     */
    blockControllerGetBlocks(options?: AxiosRequestConfig): AxiosPromise<Array<BlockReadDto>>;

    /**
     * 
     * @param {string} blockId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApiInterface
     */
    blockControllerGetLessonQuestions(blockId: string, options?: AxiosRequestConfig): AxiosPromise<Array<BlockReadDto>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApiInterface
     */
    blockControllerTestImage(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} id 
     * @param {BlockUpdateDto} blockUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApiInterface
     */
    blockControllerUpdateBlock(id: string, blockUpdateDto: BlockUpdateDto, options?: AxiosRequestConfig): AxiosPromise<BlockCreateDto>;

}

/**
 * BlocksApi - object-oriented interface
 * @export
 * @class BlocksApi
 * @extends {BaseAPI}
 */
export class BlocksApi extends BaseAPI implements BlocksApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {LessonCreateDto} lessonCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public blockControllerAddLesson(id: string, lessonCreateDto: LessonCreateDto, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).blockControllerAddLesson(id, lessonCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {QuestionCreateDto} questionCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public blockControllerAddQuestion(id: string, questionCreateDto: QuestionCreateDto, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).blockControllerAddQuestion(id, questionCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BlockCreateDto} blockCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public blockControllerCreateBlock(blockCreateDto: BlockCreateDto, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).blockControllerCreateBlock(blockCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public blockControllerDeleteAll(options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).blockControllerDeleteAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public blockControllerDeleteBlock(id: string, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).blockControllerDeleteBlock(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public blockControllerGetBlock(id: string, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).blockControllerGetBlock(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public blockControllerGetBlocks(options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).blockControllerGetBlocks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} blockId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public blockControllerGetLessonQuestions(blockId: string, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).blockControllerGetLessonQuestions(blockId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public blockControllerTestImage(options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).blockControllerTestImage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {BlockUpdateDto} blockUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public blockControllerUpdateBlock(id: string, blockUpdateDto: BlockUpdateDto, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).blockControllerUpdateBlock(id, blockUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DEVELOPMENTApi - axios parameter creator
 * @export
 */
export const DEVELOPMENTApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerCreateBlock: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/dev/createBlock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerGetLogsByWallet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/dev/delete/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerMakeMeAdmin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/dev/make/me/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerNormalizeAdmins: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/dev/normalizeAdmins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DEVELOPMENTApi - functional programming interface
 * @export
 */
export const DEVELOPMENTApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DEVELOPMENTApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devControllerCreateBlock(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devControllerCreateBlock(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devControllerGetLogsByWallet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devControllerGetLogsByWallet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devControllerMakeMeAdmin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devControllerMakeMeAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devControllerNormalizeAdmins(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devControllerNormalizeAdmins(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DEVELOPMENTApi - factory interface
 * @export
 */
export const DEVELOPMENTApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DEVELOPMENTApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerCreateBlock(options?: any): AxiosPromise<void> {
            return localVarFp.devControllerCreateBlock(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerGetLogsByWallet(options?: any): AxiosPromise<void> {
            return localVarFp.devControllerGetLogsByWallet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerMakeMeAdmin(options?: any): AxiosPromise<void> {
            return localVarFp.devControllerMakeMeAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerNormalizeAdmins(options?: any): AxiosPromise<void> {
            return localVarFp.devControllerNormalizeAdmins(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DEVELOPMENTApi - interface
 * @export
 * @interface DEVELOPMENTApi
 */
export interface DEVELOPMENTApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DEVELOPMENTApiInterface
     */
    devControllerCreateBlock(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DEVELOPMENTApiInterface
     */
    devControllerGetLogsByWallet(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DEVELOPMENTApiInterface
     */
    devControllerMakeMeAdmin(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DEVELOPMENTApiInterface
     */
    devControllerNormalizeAdmins(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * DEVELOPMENTApi - object-oriented interface
 * @export
 * @class DEVELOPMENTApi
 * @extends {BaseAPI}
 */
export class DEVELOPMENTApi extends BaseAPI implements DEVELOPMENTApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DEVELOPMENTApi
     */
    public devControllerCreateBlock(options?: AxiosRequestConfig) {
        return DEVELOPMENTApiFp(this.configuration).devControllerCreateBlock(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DEVELOPMENTApi
     */
    public devControllerGetLogsByWallet(options?: AxiosRequestConfig) {
        return DEVELOPMENTApiFp(this.configuration).devControllerGetLogsByWallet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DEVELOPMENTApi
     */
    public devControllerMakeMeAdmin(options?: AxiosRequestConfig) {
        return DEVELOPMENTApiFp(this.configuration).devControllerMakeMeAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DEVELOPMENTApi
     */
    public devControllerNormalizeAdmins(options?: AxiosRequestConfig) {
        return DEVELOPMENTApiFp(this.configuration).devControllerNormalizeAdmins(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FrontAreaApi - axios parameter creator
 * @export
 */
export const FrontAreaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Calculates users block test result
         * @param {UserTestResultDto} userTestResultDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerCheckResult: async (userTestResultDto: UserTestResultDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userTestResultDto' is not null or undefined
            assertParamExists('frontControllerCheckResult', 'userTestResultDto', userTestResultDto)
            const localVarPath = `/bck/fr/checkAnswers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userTestResultDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare and sends user questions for block testing
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerGetBlockTest: async (blockId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('frontControllerGetBlockTest', 'blockId', blockId)
            const localVarPath = `/bck/fr/questions/{blockId}`
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns blocks and lessons for front page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerGetBlocks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/fr/blocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerGetLesson: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('frontControllerGetLesson', 'id', id)
            const localVarPath = `/bck/fr/lesson/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns user lessons/blocks progress and results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerGetMyResult: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/fr/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Saves lesson reading progress or mark as read if progress not sent
         * @param {string} lessonId 
         * @param {number} [progress] null - lesson finished, 1+ - save progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerMarkAsRead: async (lessonId: string, progress?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lessonId' is not null or undefined
            assertParamExists('frontControllerMarkAsRead', 'lessonId', lessonId)
            const localVarPath = `/bck/fr/markAsRead/{lessonId}`
                .replace(`{${"lessonId"}}`, encodeURIComponent(String(lessonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (progress !== undefined) {
                localVarQueryParameter['progress'] = progress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare and sends user signature to proceed claim
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerUserPostClaimData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/fr/userClaimData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FrontAreaApi - functional programming interface
 * @export
 */
export const FrontAreaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FrontAreaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Calculates users block test result
         * @param {UserTestResultDto} userTestResultDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async frontControllerCheckResult(userTestResultDto: UserTestResultDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTestCheckResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.frontControllerCheckResult(userTestResultDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prepare and sends user questions for block testing
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async frontControllerGetBlockTest(blockId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionPublicDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.frontControllerGetBlockTest(blockId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns blocks and lessons for front page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async frontControllerGetBlocks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockReadDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.frontControllerGetBlocks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async frontControllerGetLesson(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.frontControllerGetLesson(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns user lessons/blocks progress and results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async frontControllerGetMyResult(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSummaryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.frontControllerGetMyResult(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Saves lesson reading progress or mark as read if progress not sent
         * @param {string} lessonId 
         * @param {number} [progress] null - lesson finished, 1+ - save progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async frontControllerMarkAsRead(lessonId: string, progress?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.frontControllerMarkAsRead(lessonId, progress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prepare and sends user signature to proceed claim
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async frontControllerUserPostClaimData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.frontControllerUserPostClaimData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FrontAreaApi - factory interface
 * @export
 */
export const FrontAreaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FrontAreaApiFp(configuration)
    return {
        /**
         * 
         * @summary Calculates users block test result
         * @param {UserTestResultDto} userTestResultDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerCheckResult(userTestResultDto: UserTestResultDto, options?: any): AxiosPromise<UserTestCheckResultDto> {
            return localVarFp.frontControllerCheckResult(userTestResultDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prepare and sends user questions for block testing
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerGetBlockTest(blockId: string, options?: any): AxiosPromise<Array<QuestionPublicDto>> {
            return localVarFp.frontControllerGetBlockTest(blockId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns blocks and lessons for front page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerGetBlocks(options?: any): AxiosPromise<Array<BlockReadDto>> {
            return localVarFp.frontControllerGetBlocks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerGetLesson(id: string, options?: any): AxiosPromise<LessonReadDto> {
            return localVarFp.frontControllerGetLesson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns user lessons/blocks progress and results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerGetMyResult(options?: any): AxiosPromise<UserSummaryDto> {
            return localVarFp.frontControllerGetMyResult(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Saves lesson reading progress or mark as read if progress not sent
         * @param {string} lessonId 
         * @param {number} [progress] null - lesson finished, 1+ - save progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerMarkAsRead(lessonId: string, progress?: number, options?: any): AxiosPromise<void> {
            return localVarFp.frontControllerMarkAsRead(lessonId, progress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prepare and sends user signature to proceed claim
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontControllerUserPostClaimData(options?: any): AxiosPromise<void> {
            return localVarFp.frontControllerUserPostClaimData(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FrontAreaApi - interface
 * @export
 * @interface FrontAreaApi
 */
export interface FrontAreaApiInterface {
    /**
     * 
     * @summary Calculates users block test result
     * @param {UserTestResultDto} userTestResultDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApiInterface
     */
    frontControllerCheckResult(userTestResultDto: UserTestResultDto, options?: AxiosRequestConfig): AxiosPromise<UserTestCheckResultDto>;

    /**
     * 
     * @summary Prepare and sends user questions for block testing
     * @param {string} blockId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApiInterface
     */
    frontControllerGetBlockTest(blockId: string, options?: AxiosRequestConfig): AxiosPromise<Array<QuestionPublicDto>>;

    /**
     * 
     * @summary Returns blocks and lessons for front page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApiInterface
     */
    frontControllerGetBlocks(options?: AxiosRequestConfig): AxiosPromise<Array<BlockReadDto>>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApiInterface
     */
    frontControllerGetLesson(id: string, options?: AxiosRequestConfig): AxiosPromise<LessonReadDto>;

    /**
     * 
     * @summary Returns user lessons/blocks progress and results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApiInterface
     */
    frontControllerGetMyResult(options?: AxiosRequestConfig): AxiosPromise<UserSummaryDto>;

    /**
     * 
     * @summary Saves lesson reading progress or mark as read if progress not sent
     * @param {string} lessonId 
     * @param {number} [progress] null - lesson finished, 1+ - save progress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApiInterface
     */
    frontControllerMarkAsRead(lessonId: string, progress?: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Prepare and sends user signature to proceed claim
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApiInterface
     */
    frontControllerUserPostClaimData(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * FrontAreaApi - object-oriented interface
 * @export
 * @class FrontAreaApi
 * @extends {BaseAPI}
 */
export class FrontAreaApi extends BaseAPI implements FrontAreaApiInterface {
    /**
     * 
     * @summary Calculates users block test result
     * @param {UserTestResultDto} userTestResultDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApi
     */
    public frontControllerCheckResult(userTestResultDto: UserTestResultDto, options?: AxiosRequestConfig) {
        return FrontAreaApiFp(this.configuration).frontControllerCheckResult(userTestResultDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prepare and sends user questions for block testing
     * @param {string} blockId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApi
     */
    public frontControllerGetBlockTest(blockId: string, options?: AxiosRequestConfig) {
        return FrontAreaApiFp(this.configuration).frontControllerGetBlockTest(blockId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns blocks and lessons for front page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApi
     */
    public frontControllerGetBlocks(options?: AxiosRequestConfig) {
        return FrontAreaApiFp(this.configuration).frontControllerGetBlocks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApi
     */
    public frontControllerGetLesson(id: string, options?: AxiosRequestConfig) {
        return FrontAreaApiFp(this.configuration).frontControllerGetLesson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns user lessons/blocks progress and results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApi
     */
    public frontControllerGetMyResult(options?: AxiosRequestConfig) {
        return FrontAreaApiFp(this.configuration).frontControllerGetMyResult(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Saves lesson reading progress or mark as read if progress not sent
     * @param {string} lessonId 
     * @param {number} [progress] null - lesson finished, 1+ - save progress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApi
     */
    public frontControllerMarkAsRead(lessonId: string, progress?: number, options?: AxiosRequestConfig) {
        return FrontAreaApiFp(this.configuration).frontControllerMarkAsRead(lessonId, progress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prepare and sends user signature to proceed claim
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontAreaApi
     */
    public frontControllerUserPostClaimData(options?: AxiosRequestConfig) {
        return FrontAreaApiFp(this.configuration).frontControllerUserPostClaimData(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LessonsApi - axios parameter creator
 * @export
 */
export const LessonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {LessonSlideCreateDto} lessonSlideCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerAddSlide: async (id: string, lessonSlideCreateDto: LessonSlideCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lessonControllerAddSlide', 'id', id)
            // verify required parameter 'lessonSlideCreateDto' is not null or undefined
            assertParamExists('lessonControllerAddSlide', 'lessonSlideCreateDto', lessonSlideCreateDto)
            const localVarPath = `/bck/lesson/{id}/addSlide`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lessonSlideCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/lesson/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerDeleteLesson: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lessonControllerDeleteLesson', 'id', id)
            const localVarPath = `/bck/lesson/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetLesson: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lessonControllerGetLesson', 'id', id)
            const localVarPath = `/bck/lesson/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetLessonSlides: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lessonControllerGetLessonSlides', 'id', id)
            const localVarPath = `/bck/lesson/{id}/slides`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetLessons: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/lesson`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {LessonUpdateDto} lessonUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerUpdateLesson: async (id: string, lessonUpdateDto: LessonUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lessonControllerUpdateLesson', 'id', id)
            // verify required parameter 'lessonUpdateDto' is not null or undefined
            assertParamExists('lessonControllerUpdateLesson', 'lessonUpdateDto', lessonUpdateDto)
            const localVarPath = `/bck/lesson/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lessonUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LessonsApi - functional programming interface
 * @export
 */
export const LessonsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LessonsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {LessonSlideCreateDto} lessonSlideCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lessonControllerAddSlide(id: string, lessonSlideCreateDto: LessonSlideCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lessonControllerAddSlide(id, lessonSlideCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lessonControllerDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lessonControllerDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lessonControllerDeleteLesson(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lessonControllerDeleteLesson(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lessonControllerGetLesson(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lessonControllerGetLesson(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lessonControllerGetLessonSlides(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LessonSlideReadDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lessonControllerGetLessonSlides(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lessonControllerGetLessons(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LessonReadDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lessonControllerGetLessons(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {LessonUpdateDto} lessonUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lessonControllerUpdateLesson(id: string, lessonUpdateDto: LessonUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lessonControllerUpdateLesson(id, lessonUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LessonsApi - factory interface
 * @export
 */
export const LessonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LessonsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {LessonSlideCreateDto} lessonSlideCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerAddSlide(id: string, lessonSlideCreateDto: LessonSlideCreateDto, options?: any): AxiosPromise<LessonReadDto> {
            return localVarFp.lessonControllerAddSlide(id, lessonSlideCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerDeleteAll(options?: any): AxiosPromise<void> {
            return localVarFp.lessonControllerDeleteAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerDeleteLesson(id: string, options?: any): AxiosPromise<LessonReadDto> {
            return localVarFp.lessonControllerDeleteLesson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetLesson(id: string, options?: any): AxiosPromise<LessonReadDto> {
            return localVarFp.lessonControllerGetLesson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetLessonSlides(id: string, options?: any): AxiosPromise<Array<LessonSlideReadDto>> {
            return localVarFp.lessonControllerGetLessonSlides(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetLessons(options?: any): AxiosPromise<Array<LessonReadDto>> {
            return localVarFp.lessonControllerGetLessons(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {LessonUpdateDto} lessonUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerUpdateLesson(id: string, lessonUpdateDto: LessonUpdateDto, options?: any): AxiosPromise<LessonReadDto> {
            return localVarFp.lessonControllerUpdateLesson(id, lessonUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LessonsApi - interface
 * @export
 * @interface LessonsApi
 */
export interface LessonsApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {LessonSlideCreateDto} lessonSlideCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApiInterface
     */
    lessonControllerAddSlide(id: string, lessonSlideCreateDto: LessonSlideCreateDto, options?: AxiosRequestConfig): AxiosPromise<LessonReadDto>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApiInterface
     */
    lessonControllerDeleteAll(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApiInterface
     */
    lessonControllerDeleteLesson(id: string, options?: AxiosRequestConfig): AxiosPromise<LessonReadDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApiInterface
     */
    lessonControllerGetLesson(id: string, options?: AxiosRequestConfig): AxiosPromise<LessonReadDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApiInterface
     */
    lessonControllerGetLessonSlides(id: string, options?: AxiosRequestConfig): AxiosPromise<Array<LessonSlideReadDto>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApiInterface
     */
    lessonControllerGetLessons(options?: AxiosRequestConfig): AxiosPromise<Array<LessonReadDto>>;

    /**
     * 
     * @param {string} id 
     * @param {LessonUpdateDto} lessonUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApiInterface
     */
    lessonControllerUpdateLesson(id: string, lessonUpdateDto: LessonUpdateDto, options?: AxiosRequestConfig): AxiosPromise<LessonReadDto>;

}

/**
 * LessonsApi - object-oriented interface
 * @export
 * @class LessonsApi
 * @extends {BaseAPI}
 */
export class LessonsApi extends BaseAPI implements LessonsApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {LessonSlideCreateDto} lessonSlideCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApi
     */
    public lessonControllerAddSlide(id: string, lessonSlideCreateDto: LessonSlideCreateDto, options?: AxiosRequestConfig) {
        return LessonsApiFp(this.configuration).lessonControllerAddSlide(id, lessonSlideCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApi
     */
    public lessonControllerDeleteAll(options?: AxiosRequestConfig) {
        return LessonsApiFp(this.configuration).lessonControllerDeleteAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApi
     */
    public lessonControllerDeleteLesson(id: string, options?: AxiosRequestConfig) {
        return LessonsApiFp(this.configuration).lessonControllerDeleteLesson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApi
     */
    public lessonControllerGetLesson(id: string, options?: AxiosRequestConfig) {
        return LessonsApiFp(this.configuration).lessonControllerGetLesson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApi
     */
    public lessonControllerGetLessonSlides(id: string, options?: AxiosRequestConfig) {
        return LessonsApiFp(this.configuration).lessonControllerGetLessonSlides(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApi
     */
    public lessonControllerGetLessons(options?: AxiosRequestConfig) {
        return LessonsApiFp(this.configuration).lessonControllerGetLessons(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {LessonUpdateDto} lessonUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApi
     */
    public lessonControllerUpdateLesson(id: string, lessonUpdateDto: LessonUpdateDto, options?: AxiosRequestConfig) {
        return LessonsApiFp(this.configuration).lessonControllerUpdateLesson(id, lessonUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuestionsApi - axios parameter creator
 * @export
 */
export const QuestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AnswerCreateDto} answerCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerAddAnswer: async (id: string, answerCreateDto: AnswerCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionControllerAddAnswer', 'id', id)
            // verify required parameter 'answerCreateDto' is not null or undefined
            assertParamExists('questionControllerAddAnswer', 'answerCreateDto', answerCreateDto)
            const localVarPath = `/bck/question/{id}/addAnswer`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(answerCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/question/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerDeleteLesson: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionControllerDeleteLesson', 'id', id)
            const localVarPath = `/bck/question/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerGetLesson: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionControllerGetLesson', 'id', id)
            const localVarPath = `/bck/question/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerGetLessons: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/question`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {QuestionUpdateDto} questionUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerUpdateLesson: async (id: string, questionUpdateDto: QuestionUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionControllerUpdateLesson', 'id', id)
            // verify required parameter 'questionUpdateDto' is not null or undefined
            assertParamExists('questionControllerUpdateLesson', 'questionUpdateDto', questionUpdateDto)
            const localVarPath = `/bck/question/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionsApi - functional programming interface
 * @export
 */
export const QuestionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AnswerCreateDto} answerCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionControllerAddAnswer(id: string, answerCreateDto: AnswerCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionControllerAddAnswer(id, answerCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionControllerDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionControllerDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionControllerDeleteLesson(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionControllerDeleteLesson(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionControllerGetLesson(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionControllerGetLesson(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionControllerGetLessons(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionReadDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionControllerGetLessons(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {QuestionUpdateDto} questionUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionControllerUpdateLesson(id: string, questionUpdateDto: QuestionUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionControllerUpdateLesson(id, questionUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QuestionsApi - factory interface
 * @export
 */
export const QuestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AnswerCreateDto} answerCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerAddAnswer(id: string, answerCreateDto: AnswerCreateDto, options?: any): AxiosPromise<QuestionReadDto> {
            return localVarFp.questionControllerAddAnswer(id, answerCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerDeleteAll(options?: any): AxiosPromise<void> {
            return localVarFp.questionControllerDeleteAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerDeleteLesson(id: string, options?: any): AxiosPromise<QuestionReadDto> {
            return localVarFp.questionControllerDeleteLesson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerGetLesson(id: string, options?: any): AxiosPromise<QuestionReadDto> {
            return localVarFp.questionControllerGetLesson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerGetLessons(options?: any): AxiosPromise<Array<QuestionReadDto>> {
            return localVarFp.questionControllerGetLessons(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {QuestionUpdateDto} questionUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionControllerUpdateLesson(id: string, questionUpdateDto: QuestionUpdateDto, options?: any): AxiosPromise<QuestionReadDto> {
            return localVarFp.questionControllerUpdateLesson(id, questionUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestionsApi - interface
 * @export
 * @interface QuestionsApi
 */
export interface QuestionsApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {AnswerCreateDto} answerCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApiInterface
     */
    questionControllerAddAnswer(id: string, answerCreateDto: AnswerCreateDto, options?: AxiosRequestConfig): AxiosPromise<QuestionReadDto>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApiInterface
     */
    questionControllerDeleteAll(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApiInterface
     */
    questionControllerDeleteLesson(id: string, options?: AxiosRequestConfig): AxiosPromise<QuestionReadDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApiInterface
     */
    questionControllerGetLesson(id: string, options?: AxiosRequestConfig): AxiosPromise<QuestionReadDto>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApiInterface
     */
    questionControllerGetLessons(options?: AxiosRequestConfig): AxiosPromise<Array<QuestionReadDto>>;

    /**
     * 
     * @param {string} id 
     * @param {QuestionUpdateDto} questionUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApiInterface
     */
    questionControllerUpdateLesson(id: string, questionUpdateDto: QuestionUpdateDto, options?: AxiosRequestConfig): AxiosPromise<QuestionReadDto>;

}

/**
 * QuestionsApi - object-oriented interface
 * @export
 * @class QuestionsApi
 * @extends {BaseAPI}
 */
export class QuestionsApi extends BaseAPI implements QuestionsApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {AnswerCreateDto} answerCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApi
     */
    public questionControllerAddAnswer(id: string, answerCreateDto: AnswerCreateDto, options?: AxiosRequestConfig) {
        return QuestionsApiFp(this.configuration).questionControllerAddAnswer(id, answerCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApi
     */
    public questionControllerDeleteAll(options?: AxiosRequestConfig) {
        return QuestionsApiFp(this.configuration).questionControllerDeleteAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApi
     */
    public questionControllerDeleteLesson(id: string, options?: AxiosRequestConfig) {
        return QuestionsApiFp(this.configuration).questionControllerDeleteLesson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApi
     */
    public questionControllerGetLesson(id: string, options?: AxiosRequestConfig) {
        return QuestionsApiFp(this.configuration).questionControllerGetLesson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApi
     */
    public questionControllerGetLessons(options?: AxiosRequestConfig) {
        return QuestionsApiFp(this.configuration).questionControllerGetLessons(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {QuestionUpdateDto} questionUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApi
     */
    public questionControllerUpdateLesson(id: string, questionUpdateDto: QuestionUpdateDto, options?: AxiosRequestConfig) {
        return QuestionsApiFp(this.configuration).questionControllerUpdateLesson(id, questionUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SlidesApi - axios parameter creator
 * @export
 */
export const SlidesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slideControllerDeleteAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/slide/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slideControllerDeleteLesson: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('slideControllerDeleteLesson', 'id', id)
            const localVarPath = `/bck/slide/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slideControllerGetLesson: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('slideControllerGetLesson', 'id', id)
            const localVarPath = `/bck/slide/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slideControllerGetLessons: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bck/slide`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {LessonSlideUpdateDto} lessonSlideUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slideControllerUpdateLesson: async (id: string, lessonSlideUpdateDto: LessonSlideUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('slideControllerUpdateLesson', 'id', id)
            // verify required parameter 'lessonSlideUpdateDto' is not null or undefined
            assertParamExists('slideControllerUpdateLesson', 'lessonSlideUpdateDto', lessonSlideUpdateDto)
            const localVarPath = `/bck/slide/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lessonSlideUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SlidesApi - functional programming interface
 * @export
 */
export const SlidesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SlidesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slideControllerDeleteAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slideControllerDeleteAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slideControllerDeleteLesson(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonSlideReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slideControllerDeleteLesson(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slideControllerGetLesson(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonSlideReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slideControllerGetLesson(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slideControllerGetLessons(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LessonSlideReadDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slideControllerGetLessons(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {LessonSlideUpdateDto} lessonSlideUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slideControllerUpdateLesson(id: string, lessonSlideUpdateDto: LessonSlideUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonSlideReadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slideControllerUpdateLesson(id, lessonSlideUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SlidesApi - factory interface
 * @export
 */
export const SlidesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SlidesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slideControllerDeleteAll(options?: any): AxiosPromise<void> {
            return localVarFp.slideControllerDeleteAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slideControllerDeleteLesson(id: string, options?: any): AxiosPromise<LessonSlideReadDto> {
            return localVarFp.slideControllerDeleteLesson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slideControllerGetLesson(id: string, options?: any): AxiosPromise<LessonSlideReadDto> {
            return localVarFp.slideControllerGetLesson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slideControllerGetLessons(options?: any): AxiosPromise<Array<LessonSlideReadDto>> {
            return localVarFp.slideControllerGetLessons(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {LessonSlideUpdateDto} lessonSlideUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slideControllerUpdateLesson(id: string, lessonSlideUpdateDto: LessonSlideUpdateDto, options?: any): AxiosPromise<LessonSlideReadDto> {
            return localVarFp.slideControllerUpdateLesson(id, lessonSlideUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SlidesApi - interface
 * @export
 * @interface SlidesApi
 */
export interface SlidesApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesApiInterface
     */
    slideControllerDeleteAll(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesApiInterface
     */
    slideControllerDeleteLesson(id: string, options?: AxiosRequestConfig): AxiosPromise<LessonSlideReadDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesApiInterface
     */
    slideControllerGetLesson(id: string, options?: AxiosRequestConfig): AxiosPromise<LessonSlideReadDto>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesApiInterface
     */
    slideControllerGetLessons(options?: AxiosRequestConfig): AxiosPromise<Array<LessonSlideReadDto>>;

    /**
     * 
     * @param {string} id 
     * @param {LessonSlideUpdateDto} lessonSlideUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesApiInterface
     */
    slideControllerUpdateLesson(id: string, lessonSlideUpdateDto: LessonSlideUpdateDto, options?: AxiosRequestConfig): AxiosPromise<LessonSlideReadDto>;

}

/**
 * SlidesApi - object-oriented interface
 * @export
 * @class SlidesApi
 * @extends {BaseAPI}
 */
export class SlidesApi extends BaseAPI implements SlidesApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesApi
     */
    public slideControllerDeleteAll(options?: AxiosRequestConfig) {
        return SlidesApiFp(this.configuration).slideControllerDeleteAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesApi
     */
    public slideControllerDeleteLesson(id: string, options?: AxiosRequestConfig) {
        return SlidesApiFp(this.configuration).slideControllerDeleteLesson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesApi
     */
    public slideControllerGetLesson(id: string, options?: AxiosRequestConfig) {
        return SlidesApiFp(this.configuration).slideControllerGetLesson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesApi
     */
    public slideControllerGetLessons(options?: AxiosRequestConfig) {
        return SlidesApiFp(this.configuration).slideControllerGetLessons(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {LessonSlideUpdateDto} lessonSlideUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesApi
     */
    public slideControllerUpdateLesson(id: string, lessonSlideUpdateDto: LessonSlideUpdateDto, options?: AxiosRequestConfig) {
        return SlidesApiFp(this.configuration).slideControllerUpdateLesson(id, lessonSlideUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


